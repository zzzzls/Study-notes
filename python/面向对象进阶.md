<!-- TOC -->

- [类属性](#%e7%b1%bb%e5%b1%9e%e6%80%a7)
  - [什么是类属性](#%e4%bb%80%e4%b9%88%e6%98%af%e7%b1%bb%e5%b1%9e%e6%80%a7)
  - [类属性的声明](#%e7%b1%bb%e5%b1%9e%e6%80%a7%e7%9a%84%e5%a3%b0%e6%98%8e)
  - [类属性的特点](#%e7%b1%bb%e5%b1%9e%e6%80%a7%e7%9a%84%e7%89%b9%e7%82%b9)
  - [类属性的访问及修改](#%e7%b1%bb%e5%b1%9e%e6%80%a7%e7%9a%84%e8%ae%bf%e9%97%ae%e5%8f%8a%e4%bf%ae%e6%94%b9)
  - [类属性的适用场景](#%e7%b1%bb%e5%b1%9e%e6%80%a7%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af)
- [类方法](#%e7%b1%bb%e6%96%b9%e6%b3%95)
  - [基本语法](#%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95)
  - [类方法的调用执行](#%e7%b1%bb%e6%96%b9%e6%b3%95%e7%9a%84%e8%b0%83%e7%94%a8%e6%89%a7%e8%a1%8c)
  - [什么时候声明类方法](#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%a3%b0%e6%98%8e%e7%b1%bb%e6%96%b9%e6%b3%95)
- [静态方法](#%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95)
  - [基本语法](#%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95-1)
  - [什么时候声明静态方法](#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%a3%b0%e6%98%8e%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95)
  - [静态方法深入浅出](#%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba)
  - [小结](#%e5%b0%8f%e7%bb%93)
- [魔法方法](#%e9%ad%94%e6%b3%95%e6%96%b9%e6%b3%95)
  - [什么是魔法方法](#%e4%bb%80%e4%b9%88%e6%98%af%e9%ad%94%e6%b3%95%e6%96%b9%e6%b3%95)
  - [基础魔法方法](#%e5%9f%ba%e7%a1%80%e9%ad%94%e6%b3%95%e6%96%b9%e6%b3%95)
  - [属性相关](#%e5%b1%9e%e6%80%a7%e7%9b%b8%e5%85%b3)
  - [比较操作符](#%e6%af%94%e8%be%83%e6%93%8d%e4%bd%9c%e7%ac%a6)
  - [算术运算符](#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [增量赋值运算](#%e5%a2%9e%e9%87%8f%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97)
  - [类型转换](#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2)
- [反射方法](#%e5%8f%8d%e5%b0%84%e6%96%b9%e6%b3%95)
  - [什么是反射方法](#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%b0%84%e6%96%b9%e6%b3%95)
  - [常见的放射方法](#%e5%b8%b8%e8%a7%81%e7%9a%84%e6%94%be%e5%b0%84%e6%96%b9%e6%b3%95)

<!-- /TOC -->

# 类属性

生活中总会出现这样一种特征，一类事物共有的共同的特征，Python语法中提供了类型属性（简称类属性）描述表现这样的特征。

## 什么是类属性

定义给类型的属性，直接**描述一类事物的特征**，而不是具体某个对象的特征。

## 类属性的声明

类属性，声明在**类型的内部，方法的外部。**

```python
class Person:
    """人的类型"""

    # 类属性
    max_age = 150

    def __init__(self, name, age):
        self.name = name
        self.age = age
```

## 类属性的特点

类属性描述了一类事物的特征，所以可以被这个类型创建的**所有对象去访问（不能修改）**

## 类属性的访问及修改

```python
class Person:
    max_age = 150

    def __init__(self, name, age):
        self.name = name
        self.age = age

# 类属性的访问
# 1. 通过 类名.类属性 访问
>>> print(Person.max_age)
150

# 2. 通过 对象.类属性 访问
>>> man = Person("tom", 35)
>>> man.max_age
150

# 类属性的修改
# 通过 类名.类属性 修改
>>> Person.max_age = 130
>>> print(Person.max_age)
130
```

## 类属性的适用场景

类属性的出现，主要是用来描述一类事物共同的特征，如果在项目开发中，出现了类似的特征，要求所有对象都能遵循满足同一个特征数据，考虑适用类属性声明这个特征！

# 类方法

## 基本语法

```python
class 类型名称:

    ...
    
    @classmethed
    def 类方法名称(cls, [形参]):
        pass
```

- 类方法，也是一种方法，遵循方法的命名规范
- 类方法，需要在方法上边加上 `@classmethed` 装饰器声明，表示这是一个类方法
- 类方法，第一个参数 `cls` 表示的是**当前类**
- 类方法可以访问和修改类属性，通过 `cls` 直接访问和修改

## 类方法的调用执行

类方法和类属性一样，推荐**直接通过 类名.方法名调用执行**  

类方法属于一类事物的共同行为，所以通过对象也可以调用

## 什么时候声明类方法

项目中的某个类型出现了一种行为，和具体的对象无关，此时这样的行为方法，就可以被声明为类方法。

> 类属性的封装，属性的 set/get 方法必须通过类方法来实现

# 静态方法

## 基本语法

```python
class 类名:
  ...

  @staticmethod
  def get_current_time():
    return datatime.now()
```

## 什么时候声明静态方法

项目开发过程中，出现了一些功能性的方法，如**获取当前系统时间**，如此简单之行为，抽取对象声明类型，反倒有过度设计的嫌疑！
> 注意：面向对象的开发中，不要为了面向对象去专门强行设计类型，很容易造成过度设计！

**1. 声明函数实现**  

  面向对象的项目中，如果出现了一些实现独立的小功能行为，可以将这样的功能声明成函数在项目中调用执行（**面向过程 面向对象 混合开发**）

   - **优点**：函数式的实现，开发过程中适用方便，哪里需要哪里声明哪里调用！
   - **缺点**：如果没有足够的项目规范约束，项目中声明的多个函数到处都是不好维护！

**2. 静态方法实现**  

类似获取时间这样的功能性函数，如果抽取对象声明类型比较繁琐，Python语法中针对这样的函数提供了一个特殊的方法：**静态方法**。包含在任意一个类型中，通过**类型统一管理**，可以通过类型名称直接调用，但是静态方法**不能访问实例属性，也不能访问类型属性**，只起到了函数的作用！

## 静态方法深入浅出

- 静态方法声明在类型中，使用 `@staticmethod` 声明
- 静态方法既不能访问实例属性，也不能访问类属性，只起到函数的作用
- 静态方法推荐通过 类名调用执行
- 如果一个方法既不访问对象数据也不访问类数据，考虑使用静态方法

## 小结

|              | 实例方法 | 类方法 | 静态方法 |
| :----------: | :------: | :----: | :------: |
| 访问实例属性 |    Y     |   N    |    N     |
|  访问类属性  |    Y     |   Y    |    N     |

# 魔法方法

## 什么是魔法方法

魔法方法如同它的名字一样神奇，是指哪些Python内部已经包含的，**被双下划线所包围的方法**，这些方法在进行特定的操作时会被自动调用。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        """当对象被打印时调用"""
        return f"name is {self.name}, age is {self.age}"

tom = Person("tom", 18)
print(tom)
# name is tom, age is 18
```

## 基础魔法方法

|魔法方法名|描述|
|:---:|:---:|
|__new__(cls)|构造方法|
|__init__(self)|初始化方法|
|__call__(self[,...])|允许一个对象像函数一样被调用：`x(a,b)`调用`x.__call__(a,b)`|
|__len__(self)|定义当被`len()`调用时的行为|
|__repr__(self)|定义当被`repr()`调用时的行为|
|__str__(self)|定义当被`str()`调用时的行为|
|__hash__(self)|定义当被`hash()`调用时的行为|

## 属性相关

|魔法方法名|描述|
|:---:|:---:|
|__getattr__(self,name)|定义一个当用户试图获取一个不存在的属性时的行为|
|__getattribute__(self, name)|定义当该类的属性被访问时的行为|
|__setattr__(self, name, value)|	定义当一个属性被设置时的行为|
|__delattr__(self, name)|定义当一个属性被删除时的行为|
|__dir__(self)|定义当 `dir()` 被调用时的行为|

## 比较操作符 

|魔法方法名|描述|
|:---:|:---:|
|__lt__(self, other)	|定义小于号的行为：x < y 调用 `x.__lt__(y)`|
|__eq__(self, other)|	定义等于号的行为：x == y 调用 `x.__eq__(y)`|
|__ne__(self, other)	|定义不等号的行为：x != y 调用 `x.__ne__(y)`|
|__gt__(self, other)|	定义大于号的行为：x > y 调用 `x.__gt__(y)`|

## 算术运算符

|魔法方法名|描述|
|:---:|:---:|
|__add__(self, other)|	定义加法的行为：+|
|__sub__(self, other)|	定义减法的行为：-|
|__mul__(self, other)|	定义乘法的行为：*|
|__truediv__(self, other)|	定义真除法的行为：/|

## 增量赋值运算

|魔法方法名|描述|
|:---:|:---:|
|__iadd__(self, other)|	定义赋值加法的行为：+=|
|__isub__(self, other)|	定义赋值减法的行为：-=|
|__imul__(self, other)|	定义赋值乘法的行为：*=|
|__itruediv__(self, other)|	定义赋值真除法的行为：/=|

## 类型转换

|魔法方法名|描述|
|:---:|:---:|
|__int__(self)|	让当前对象支持 `int()` 类型转换操作|
|__float__(self)|	让当前对象支持 `float()` 类型转换操作|
|__bool__(self)|	让当前对象支持 `bool()` 类型转换操作|
|__str__(self)|	让当前对象支持 `str()` 类型转换操作|

... more and more


# 反射方法

## 什么是反射方法

反射方法，就是不通过方法名称调用方法，而是通过一个字符串反向解析得到方法对象执行方法的过程。

```python
# 常规
Object.study()  # 执行了 study() 方法

# 反射
method = getattr(Object, "study")
method()
```

## 常见的反射方法

|魔法方法名|描述|
|:---:|:---:|
|hasattr(obj, attr)|	判断目标对象中是否包含指定的属性或者方法|
|getattr(obj, attr)|	从目标对象中获取执行名称的属性或者方法|
|setattr(obj, attr, value)|	获取并执行目标对象中的属性或者方法|
|delattr(obj, attr)|	从目标对象中删除对应的属性或者方法|



