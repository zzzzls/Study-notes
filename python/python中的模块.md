<!-- TOC -->

- [Python中的模块](#python%e4%b8%ad%e7%9a%84%e6%a8%a1%e5%9d%97)
  - [传统代码的问题](#%e4%bc%a0%e7%bb%9f%e4%bb%a3%e7%a0%81%e7%9a%84%e9%97%ae%e9%a2%98)
    - [基础语法](#%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95)
    - [函数式开发](#%e5%87%bd%e6%95%b0%e5%bc%8f%e5%bc%80%e5%8f%91)
  - [Python中的模块](#python%e4%b8%ad%e7%9a%84%e6%a8%a1%e5%9d%97-1)
    - [什么是模块？](#%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e5%9d%97)
    - [模块化开发](#%e6%a8%a1%e5%9d%97%e5%8c%96%e5%bc%80%e5%8f%91)
  - [模块中的编码规范](#%e6%a8%a1%e5%9d%97%e4%b8%ad%e7%9a%84%e7%bc%96%e7%a0%81%e8%a7%84%e8%8c%83)
  - [模块的拆分依据和命名规范](#%e6%a8%a1%e5%9d%97%e7%9a%84%e6%8b%86%e5%88%86%e4%be%9d%e6%8d%ae%e5%92%8c%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83)
    - [软件结构](#%e8%bd%af%e4%bb%b6%e7%bb%93%e6%9e%84)
    - [模块的拆分](#%e6%a8%a1%e5%9d%97%e7%9a%84%e6%8b%86%e5%88%86)
    - [模块的命名](#%e6%a8%a1%e5%9d%97%e7%9a%84%e5%91%bd%e5%90%8d)
  - [模块的引入方式【import】](#%e6%a8%a1%e5%9d%97%e7%9a%84%e5%bc%95%e5%85%a5%e6%96%b9%e5%bc%8fimport)
    - [绝对引入](#%e7%bb%9d%e5%af%b9%e5%bc%95%e5%85%a5)
    - [相对引入](#%e7%9b%b8%e5%af%b9%e5%bc%95%e5%85%a5)
  - [Python中的 main方法](#python%e4%b8%ad%e7%9a%84-main%e6%96%b9%e6%b3%95)

<!-- /TOC -->

# Python中的模块

## 传统代码的问题

> 为什么会有模块?

项目进行时，根据需求分析得到功能，通过代码进行还原，这是编写代码执行软件开发的流程，但是当**项目中的功能增加**时……

### 基础语法

&nbsp;&nbsp;&nbsp;&nbsp;当功能增加，此时项目中出现了大量的控制程序运行流程的 `if - else` 选择结构语句和 `while` 循环流程语句，在流程语句中出现了大量的 `continue/break/else`  
&nbsp;&nbsp;&nbsp;&nbsp;**问题：当功能增加，代码缩进到一定程度，代码的可读性严重下降，同时对于代码中的功能需要更改的话，基本不敢动代码，很有可能一行代码的修改将导致整个流程的混乱。**

### 函数式开发

&nbsp;&nbsp;&nbsp;&nbsp;通过函数将不同的代码片段封装起来，通过函数互相调用和递归调用的方式，完成以前了由 `while` 循环控制的运行过程，函数本身就是程序执行步骤和执行过程，代码的大量缩进问题和流程问题得到了非常好的解决，函数的出现提高了函数内部代码的复用性。  
&nbsp;&nbsp;&nbsp;&nbsp;**问题：但是随着功能的增加，发现一个文件中的函数代码快速的增多，最终导致单个文件中的函数数量太多，代码的可读性就开始下降，同时程序中出现问题的时候修改函数代码开始变得困难。**

## Python中的模块

### 什么是模块？

&nbsp;&nbsp;&nbsp;&nbsp;Python中的模块，核心就是 python文件，**一个独立的 python文件，就是一个 python模块。**

### 模块化开发

将项目中的代码，根据不同的功能，拆分到不同的多个 python文件中，将代码包含到多个 python模块中，这样的开发方式会使 **一个项目中包含多个 python文件**，但是 **每个文件中的代码足够简单**。 这样的开发模式被称为 **模块化开发【多文件开发】**

## 模块中的编码规范

```python
demo.py 模块(demo.py文件)
------------------------------
"""
位置1、模块的文档注释
"""

# 位置2、引入系统模块
import random
import time

# 位置3、引入自定义模块/第三方模块
import my_python

# 位置4、声明全局变量
users_dict = dict()

# 位置5、声明函数
def show_login():
    pass

# 特殊位置6：编写当前模块的测试用的代码
if __name__ ==  "__main__":
    # 写测试代码的地方
```

## 模块的拆分依据和命名规范

### 软件结构

软件是和用户完成具体问题处理和解决的工具，操作过程中软件出席那了它的基本架构：

- 界面部分
  - 展示给用户的可视化界面
- 数据处理部分
  - 专门完成业务功能的数据运算和逻辑处理
- 数据存储部分
  - 完成项目中业务数据的存储功能

![img][img@1]

### 模块的拆分

**1. 从已开发的软件中，描述生活场景**

![img][img@2]

**2. 按照生活场景，还原软件的过程，描述模块的拆分**  

项目中有**两种常见的拆分方式**，大家可以按照拆分一句进行灵活选择

- 角色拆分
  - 中大型项目中，**用户的角色会区分多种**（游客，会员，SVIP，管理员等）操作过程中根据不同的角色，拆分每个角色自己的功能模块

- 功能拆分
  - 大中小型项目通用，根据软件的分层思想，将不同功能的处理代码划分到独立的文件中进行管理（展示界面的功能，处理数据的功能，存储数据的功能...）

### 模块的命名

按照功能进行拆分，将不同的代码拆分到了四个不同的文件中：

|  模块名称   |                        模块描述                        |
| :---------: | :----------------------------------------------------: |
|   data.py   |          声明变量，存储系统中的所有数据的模块          |
| services.py | 声明数据处理函数，处理系统中的所有业务，如注册，登录等 |
|  views.py   |  声明展示界面的函数，处理系统中展示给用户的可视化界面  |
|   main.py   |                     程序运行的入口                     |

## 模块的引入方式【import】

数据初始化：创建一个项目文件夹  
初始化四个 python模块：`data.py、services.py、views.py、main.py`

1. 示例开发：四个模块的访问

程序从 `main.py` 启动 `引入views.py`  
--> 访问到 `views.py` 中的函数 `引入services.py`  
--> -- 访问到 `services.py` 中的函数 `引入data.py`  
--> -- -- 访问到 `data.py` 中的变量数据  

![img][img@3]

### 绝对引入

绝对引入，就是按照系统的绝对路径从磁盘上指定的文件夹中查询要引入的模块  

1. 解释器的 `site_packages` 文件夹
2. 系统的 `PYTHONOATH `环境变量
3. 当前文件夹

**引入方式**

1.推荐使用
- `import 模块名称`

- `import 模块名称 as 别名`

2.不推荐使用，可能引起当前文件的全局污染
- `from 模块名称 import 变量，函数名称`

- `from 模块名称 import *`

### 相对引入

相对引入，使用当前文件的相对路径去查找引入的模块，一旦使用了相对引入，解析器就不再主动帮助查询需要的模块的所在位置，需要由运行命令来指定加载的模块才能正常运行

**引入方式**

1.推荐使用  
- `from . import 模块名称`

- `from . import 模块名称 as 别名`

1. 不推荐使用
- `from .模块名称 import 变量, 函数`

- `from .模块名称 import *`

**相对引入的过程中，需要注意的问题，运行方式发生了变化：**

![img][img@4]

## Python中的 main方法

为了保证程序代码，能够在模块化多文件开发模式下，正常的完成程序入口的定义，python提供了一个模拟的 main方法  

```python
# 只有当前文件作为入口程序的时候，这些代码才会运行
if __name__ == "__main__":
     print("hello world!")   

```

**注意：**
- 当 python文件直接运行时，`__name__` 的值为 `main`
- 当 python文件被当作模块调用时，`__name__` 的值为 **当前模块名**

[img@1]:https://raw.githubusercontent.com/zzzzls/Images/master/Study_nodes_img/python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/04-13_01.png
[img@2]:https://raw.githubusercontent.com/zzzzls/Images/master/Study_nodes_img/python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/04-13_02.png
[img@3]:https://raw.githubusercontent.com/zzzzls/Images/master/Study_nodes_img/python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/04-13_03.png
[img@4]:https://raw.githubusercontent.com/zzzzls/Images/master/Study_nodes_img/python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/04-13_04.png